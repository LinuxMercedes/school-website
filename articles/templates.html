<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Template Classes and Friend Function Details</title>
<link href="../style.css" rel="stylesheet" type="text/css">
<!-- Styling for vim syntax hilighting -->
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #DCDCDC; float:left; }
p {clear:both;}
.lnr { color: #804000; }
.Constant { color: #c00000; }
.Statement { color: #804000; }
.Type { color: #008000; }
h3 { display:block; }
-->
</style>

</head>
<body>
<div><a href="..">Home</a> <a href="index.html">Articles</a><hr></div>
<h2>C++ Template Classes and Friend Function Details</h2>
<h3>Introduction</h3>
<p>In C++, there are a few different ways to set up template classes with friend functions.
Each behaves in a subtly different way, which causes all sorts of confusion when trying to finish your homework the night before it's due.
We will examine the possible approaches to this, but first...
</p>

<h3>Some terminology</h3>
<p><b>Template instantiation</b>: A specific instance of a templated item; for example, if we have a templated class A, A&lt;int&gt; is a specific
instantiation of A. </p>
<p><b>Free function</b>: A function that is not a member of a class. We will examine these in the context of friend functions in this article.</p>

<h3>Approach #1</h3>
<pre>
<span class="lnr"> 1 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 2 </span><span class="Type">class</span> A
<span class="lnr"> 3 </span>{
<span class="lnr"> 4 </span>  <span class="Statement">public</span>:
<span class="lnr"> 5 </span>    A(T a = <span class="Constant">0</span>): m_a(a) {}
<span class="lnr"> 6 </span>
<span class="lnr"> 7 </span>    <span class="Type">template</span>&lt;<span class="Type">class</span> U&gt;
<span class="lnr"> 8 </span>    <span class="Statement">friend</span> A&lt;U&gt; foo(A&lt;U&gt;&amp; a);
<span class="lnr"> 9 </span>
<span class="lnr">10 </span>  <span class="Statement">private</span>:
<span class="lnr">11 </span>    T m_a;
<span class="lnr">12 </span>};
<span class="lnr">13 </span>
<span class="lnr">14 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr">15 </span>A&lt;T&gt; foo(A&lt;T&gt;&amp; a)
<span class="lnr">16 </span>{
<span class="lnr">17 </span>  <span class="Statement">return</span> a;
<span class="lnr">18 </span>}
<span class="lnr">19 </span>
</pre>

<p>This approach is the most permissive approach to declaring a templated friend function of a templated class.
This will work for all cases where you want to explicitly pass an instance of A to foo(). 
</p>

<p>However, there is one unapparent side effect of this approach: All template instantiations of A are friends with all template instantiations of foo(), i.e.
A&lt;int&gt; is friends with foo&lt;int&gt; but also foo&lt;double&gt;. 
Since this can pose some security issues by allowing people to make functions that are friends with all your template instances, we want a different approach that's a bit more picky about its friends, which brings us to
</p>
<h3>Approach #2</h3>
<pre>
<span class="lnr"> 1 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 2 </span><span class="Type">class</span> A;
<span class="lnr"> 3 </span>
<span class="lnr"> 4 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 5 </span>A&lt;T&gt; foo(A&lt;T&gt;&amp; a);
<span class="lnr"> 6 </span>
<span class="lnr"> 7 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 8 </span><span class="Type">class</span> A
<span class="lnr"> 9 </span>{
<span class="lnr">10 </span>  <span class="Statement">public</span>:
<span class="lnr">11 </span>    A(T a = <span class="Constant">0</span>): m_a(a) {}
<span class="lnr">12 </span>
<span class="lnr">13 </span>    <span class="Statement">friend</span> A foo&lt;T&gt;(A&amp; a);
<span class="lnr">14 </span>
<span class="lnr">15 </span>  <span class="Statement">private</span>:
<span class="lnr">16 </span>    T m_a;
<span class="lnr">17 </span>};
<span class="lnr">18 </span>
<span class="lnr">19 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr">20 </span>A&lt;T&gt; foo(A&lt;T&gt;&amp; a)
<span class="lnr">21 </span>{
<span class="lnr">22 </span>  <span class="Statement">return</span> a;
<span class="lnr">23 </span>}
<span class="lnr">24 </span>
</pre>

<p> This approach is a bit more ugly, but it fixes the security issue with approach #1. 
Here, foo() is declared as a template function using a declared (but not yet defined) templated class A. 
A then later defines the template instantiation of foo() matching the template instantiation of A as a friend. 
(In case you're wondering why on line 13 A is used with no &lt;T&gt; after it: inside class definitions, C++
 assumes that any reference to that class is templated, so adding the &lt;T&gt; is redundant.) </p>
<p>This may seem like a minor difference from approach #1, but in this case 
A&lt;int&gt; is friends with foo&lt;int&gt;, but foo&lt;double&gt; is not a friend of A&lt;int&gt; since foo&lt;double&gt; has a
different template instantiation. 
</p>

<p>In general, this is how template friend functions are done in best practices.
They are explicit in the type of object they will take as parameters and do not allow different template instantiations to be friends.
However, in certain edge cases, such as numeric type objects, these friend functions have an undesirable side effect: 
since they are template functions, the parameters passed to them must be explicitly associated with the expected parameter types
for template argument deduction to succeed. To illustrate, </p>

<pre>
<span class="lnr"> 1 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 2 </span><span class="Type">class</span> A;
<span class="lnr"> 3 </span>
<span class="lnr"> 4 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 5 </span>A&lt;T&gt; foo(A&lt;T&gt;&amp; a);
<span class="lnr"> 6 </span>
<span class="lnr"> 7 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 8 </span><span class="Type">class</span> A
<span class="lnr"> 9 </span>{
<span class="lnr">10 </span>  <span class="Statement">public</span>:
<span class="lnr">11 </span>    A(T a = <span class="Constant">0</span>): m_a(a) {}
<span class="lnr">12 </span>
<span class="lnr">13 </span>    <span class="Statement">friend</span> A foo&lt;T&gt;(A&amp; a);
<span class="lnr">14 </span>
<span class="lnr">15 </span>  <span class="Statement">private</span>:
<span class="lnr">16 </span>    T m_a;
<span class="lnr">17 </span>};
<span class="lnr">18 </span>
<span class="lnr">19 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr">20 </span>A&lt;T&gt; foo(A&lt;T&gt;&amp; a)
<span class="lnr">21 </span>{
<span class="lnr">22 </span>  <span class="Statement">return</span> a;
<span class="lnr">23 </span>}
<span class="lnr">24 </span>
<span class="lnr">25 </span><span class="Type">int</span> main()
<span class="lnr">26 </span>{
<span class="lnr">27 </span>  A&lt;<span class="Type">int</span>&gt; a(<span class="Constant">5</span>);
<span class="lnr">28 </span>  <span class="Type">int</span> i = <span class="Constant">4</span>;
<span class="lnr">29 </span>
<span class="lnr">30 </span>  foo(a); <span class="Comment">// Succeeds</span>
<span class="lnr">31 </span>  foo(i); <span class="Comment">// Cannot deduce template parameters</span>
<span class="lnr">32 </span>
<span class="lnr">33 </span>  <span class="Statement">return</span> <span class="Constant">0</span>;
<span class="lnr">34 </span>}
<span class="lnr">35 </span>
</pre>

<p>On line 31, despite there being an implicit conversion from int to A&lt;int&gt;, that conversion is not made. 
This is because C++ never considers implicit conversions for template parameter deduction on free template functions. 
For the most part, this is not a problem because it prevents certain amounts of ambiguity when dealing with calling template functions, 
but in the case where we are working with numeric type classes, we do want the implicit conversion to occur.
</p>

<h3>Approach #3</h3>
<p>As we saw in approach #2, C++ won't implicitly convert types for template function parameters, even if such a conversion exists.
But in the case where we are working with numeric types, we want that conversion to occur. 
So, how can we achieve this? Well, C++ will perform implicit type conversion on non-templated free functions. 
What if we were to create some non-template friend function that was automatically created for each template instantiation of 
some class? As it turns out, that is possible:</p>
<pre>
<span class="lnr"> 1 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 2 </span><span class="Type">class</span> A
<span class="lnr"> 3 </span>{
<span class="lnr"> 4 </span>  <span class="Statement">public</span>:
<span class="lnr"> 5 </span>    A(T a = <span class="Constant">0</span>): m_a(a) {}
<span class="lnr"> 6 </span>
<span class="lnr"> 7 </span>    <span class="Statement">friend</span> A <span class="Statement">operator</span>+(<span class="Type">const</span> A&amp; lhs, <span class="Type">const</span> A&amp; rhs)
<span class="lnr"> 8 </span>    {
<span class="lnr"> 9 </span>      <span class="Statement">return</span> lhs.m_a + rhs.m_a;
<span class="lnr">10 </span>    }
<span class="lnr">11 </span>
<span class="lnr">12 </span>  <span class="Statement">private</span>:
<span class="lnr">13 </span>    T m_a;
<span class="lnr">14 </span>};
<span class="lnr">15 </span>
<span class="lnr">16 </span><span class="Type">int</span> main()
<span class="lnr">17 </span>{
<span class="lnr">18 </span>  A&lt;<span class="Type">int</span>&gt; a(<span class="Constant">5</span>);
<span class="lnr">19 </span>  A&lt;<span class="Type">int</span>&gt; b(<span class="Constant">7</span>);
<span class="lnr">20 </span>  <span class="Type">int</span> i = <span class="Constant">4</span>;
<span class="lnr">21 </span>
<span class="lnr">22 </span>  a + b;    <span class="Comment">// Succeeds</span>
<span class="lnr">23 </span>  i + a;    <span class="Comment">// Also succeeds</span>
<span class="lnr">24 </span>  <span class="Statement">return</span> <span class="Constant">0</span>;
<span class="lnr">25 </span>}
<span class="lnr">26 </span>
</pre>

<p>Here, operator+ is a friend function, but is not templated. Instead, it is a function that is automatically created
for each template instantiation of A when that template is instantiated. The generic definition must be inlined in the
class definition because operator+ doesn't exist outside the class definition of A until A is instantiated, which happens
during the compilation process. It is possible to write specific definitions of operator+ outside of A, but no generic
definition can be written because operator+ is not a template function: </p>
<pre>
<span class="lnr"> 1 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 2 </span><span class="Type">class</span> A
<span class="lnr"> 3 </span>{
<span class="lnr"> 4 </span>  <span class="Statement">public</span>:
<span class="lnr"> 5 </span>    A(T a = <span class="Constant">0</span>): m_a(a) {}
<span class="lnr"> 6 </span>
<span class="lnr"> 7 </span>    <span class="Statement">friend</span> A <span class="Statement">operator</span>+(<span class="Type">const</span> A&amp; lhs, <span class="Type">const</span> A&amp; rhs);
<span class="lnr"> 8 </span>
<span class="lnr"> 9 </span>  <span class="Statement">private</span>:
<span class="lnr">10 </span>    T m_a;
<span class="lnr">11 </span>};
<span class="lnr">12 </span>
<span class="lnr">13 </span><span class="Type">inline</span> A&lt;<span class="Type">int</span>&gt; <span class="Statement">operator</span>+(<span class="Type">const</span> A&lt;<span class="Type">int</span>&gt;&amp; lhs, <span class="Type">const</span> A&lt;<span class="Type">int</span>&gt;&amp; rhs)
<span class="lnr">14 </span>{
<span class="lnr">15 </span>  <span class="Statement">return</span> lhs.m_a + rhs.m_a;
<span class="lnr">16 </span>}
<span class="lnr">17 </span>
<span class="lnr">18 </span><span class="Type">int</span> main()
<span class="lnr">19 </span>{
<span class="lnr">20 </span>  A&lt;<span class="Type">int</span>&gt; a(<span class="Constant">5</span>);
<span class="lnr">21 </span>  A&lt;<span class="Type">int</span>&gt; b(<span class="Constant">7</span>);
<span class="lnr">22 </span>  <span class="Type">int</span> i = <span class="Constant">4</span>;
<span class="lnr">23 </span>
<span class="lnr">24 </span>  a + b;    <span class="Comment">// Succeeds</span>
<span class="lnr">25 </span>  i + a;    <span class="Comment">// Also succeeds</span>
<span class="lnr">26 </span>  <span class="Statement">return</span> <span class="Constant">0</span>;
<span class="lnr">27 </span>}
<span class="lnr">28 </span>
</pre>

<p>However, this code won't compile without warnings in gcc, and is uninteresting anyway because we don't want to write
specific implementations of operator+ for each template instantiation of A. The warning itself indicates that 
this is possible, but not usually what you want to do.</p>
<p>Now, you may be wondering why I switched my example function defnition. As it turns out, declaring non-template
friend functions like this puts them in a VERY strange place as far as being able to refer to them goes. 
C++ has a feature called ADL, or Argument Dependent Lookup, that can search through functions that aren't in the current
scope, but exist in a class or namespace that is suggested by the type of the arguments handed to the function call:</p>

<pre>
<span class="lnr"> 1 </span><span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="lnr"> 2 </span><span class="Type">class</span> A
<span class="lnr"> 3 </span>{
<span class="lnr"> 4 </span>  <span class="Statement">public</span>:
<span class="lnr"> 5 </span>    A(T a = <span class="Constant">0</span>): m_a(a) {}
<span class="lnr"> 6 </span>
<span class="lnr"> 7 </span>    <span class="Statement">friend</span> A <span class="Statement">operator</span>+(<span class="Type">const</span> A&amp; lhs, <span class="Type">const</span> A&amp; rhs)
<span class="lnr"> 8 </span>    {
<span class="lnr"> 9 </span>      <span class="Statement">return</span> lhs.m_a + rhs.m_a;
<span class="lnr">10 </span>    }
<span class="lnr">11 </span>
<span class="lnr">12 </span>    <span class="Statement">friend</span> A foo(A&amp; a)
<span class="lnr">13 </span>    {
<span class="lnr">14 </span>      <span class="Statement">return</span> a;
<span class="lnr">15 </span>    }
<span class="lnr">16 </span>
<span class="lnr">17 </span>  <span class="Statement">private</span>:
<span class="lnr">18 </span>    T m_a;
<span class="lnr">19 </span>};
<span class="lnr">20 </span>
<span class="lnr">21 </span><span class="Type">int</span> main()
<span class="lnr">22 </span>{
<span class="lnr">23 </span>  A&lt;<span class="Type">int</span>&gt; a(<span class="Constant">5</span>);
<span class="lnr">24 </span>  A&lt;<span class="Type">int</span>&gt; b(<span class="Constant">7</span>);
<span class="lnr">25 </span>  <span class="Type">int</span> i = <span class="Constant">4</span>;
<span class="lnr">26 </span>
<span class="lnr">27 </span>  a + b;    <span class="Comment">// Succeeds </span>
<span class="lnr">28 </span>  i + a;    <span class="Comment">// Also succeeds</span>
<span class="lnr">29 </span>
<span class="lnr">30 </span>  foo(a);   <span class="Comment">// Succeeds</span>
<span class="lnr">31 </span>  foo(i);   <span class="Comment">// Fails</span>
<span class="lnr">32 </span>  foo(A&lt;<span class="Type">int</span>&gt;(i)); <span class="Comment">// Succeeds</span>
<span class="lnr">33 </span>  <span class="Statement">return</span> <span class="Constant">0</span>;
<span class="lnr">34 </span>}
<span class="lnr">35 </span>
</pre>

<p>Here, line 28 succeeds because of ADL: even though foo() is not in the current scope, C++ can see that the second argument to operator+ is A&lt;int&gt;
and therefore will attempt to implicitly convert i to A&lt;int&gt; because foo() is not a template function and thus follows standard implicit conversion
rules for non-template free functions. Since C++ does have a way to convert int to A&lt;int&gt;, the call succeeds.</p>
<p>However, the call on line 31 fails because foo() is not in the current scope, and no parameter in foo() hints that C++ needs to use ADL to consider functions
not in the current scope.</p>
<p>Line 32 succeeds because the parameter to foo() is explicitly of type A&lt;int&gt;, and thus C++ uses ADL to look up foo(). </p>
<p>This issue with ADL not always looking up a function when it exists is reason to not use this approach with most classes and instead explicitly
convert the parameters to the correct types for foo(). And, if you're already explicitly converting types, you may as well use approach #2 and 
lose all the complexity of approach #3.</p>
<p>But, in the case where you require implicit type conversions on friend functions of template classes and can guarantee that ADL will succeed
in your function calls, approach #3 will work, but be aware that it can break easily if you rely on too much implicit type conversion.</p>

<h3>Sources and Further Reading</h3>
<ul>
<li>Effective C++, Scott Meyers; particularly Items #24 and #46 (available via Safari Books)</li>
<li>C++ Templates: The Complete Guide, David Vandervoorde, Nicolai M. Josuttis; pages 174-177</li>
<li><a href="http://stackoverflow.com/a/4661372">The three different approaches to template class friend functions</a></li>
<li><a href="http://stackoverflow.com/a/10378406">More on approaches to template class friend functions</a></li>
<li><a href="http://stackoverflow.com/a/12187345">A few more details on the third approach</a></li>
<li><a href="http://stackoverflow.com/a/2405478">ADL for template parameter deduction and shortcomings of ADL</a></li>
<li><a href="http://en.wikipedia.org/wiki/Argument-dependent_name_lookup">Wikipedia page for ADL</a></li>
</ul>

</body>
</html>
