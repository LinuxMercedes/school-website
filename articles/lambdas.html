<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Lambdas Under The Hood</title>
<link href="../style.css" rel="stylesheet" type="text/css">
<!-- Styling for vim syntax hilighting -->
<style type="text/css">
<!--
/*pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #DCDCDC; float:left; margin:5px; padding:2px;}
.lnr { color: #804000; }
.Constant { color: #c00000; }
.Statement { color: #804000; }
.Type { color: #008000; }
*/
pre { white-space: pre-wrap; font-family: monospace; color: #202020; background-color: #eeeeee; }
.Type { color: #af5faf; }
.LineNr { color: #808080; }
.Comment { color: #505050; }
.Constant { color: #0087ff; }
.String { color: #005fd7; }
.PreProc { color: #00d75f; }
.Statement { color: #875faf; }
.CPP { color: #af5faf; }
.Header { color: #875faf; }
p { clear:both; }
pre { float:left; margin:5px; padding:2px; }
h3 { display:block; }
code { color: #202020; background-color:#eeeeee; }
-->
</style>

</head>
<body>
<div><a href="..">Home</a> <a href="index.html">Articles</a><hr></div>
<h2>C++ Lambdas Under The Hood</h2>
<h3>Introduction</h3>
<p>
C++11 introduced lambdas, which provide a syntactically lightweight way to define functions on-the-fly.
They can also capture (or close over) variables from the surrounding scope, either by value or by reference.
In this article, we investigate how lambdas differ, implementation-wise, from plain functions and functor classes (classes that implement <code>operator()</code>).
</p>
<p>
Source files, along with a makefile to generate disassemblies, are available <a href="lambdas">here</a>.
All assembly code was generated by GCC version 6.2.1 with no optimizations and the <code>-g</code> flag enabled.
</p>

<h3>No Capturing</h3>
<p>
We first investigate lambdas that do not capture any variables. C++ offers three alternatives: plain functions, functor classes, and lambdas.
This listing demonstrates each approach for a simple operation:
</p>
<p>
<pre id='vimCodeElement'>
<span id="L1" class="LineNr"> 1 </span><span class="Type">int</span> function (<span class="Type">int</span> a) {
<span id="L2" class="LineNr"> 2 </span>  <span class="Statement">return</span> a + <span class="Constant">3</span>;
<span id="L3" class="LineNr"> 3 </span>}
<span id="L4" class="LineNr"> 4 </span>
<span id="L5" class="LineNr"> 5 </span><span class="Type">class</span> Functor {
<span id="L6" class="LineNr"> 6 </span>  <span class="Statement">public</span>:
<span id="L7" class="LineNr"> 7 </span>    <span class="Type">int</span> <span class="Operator">operator</span>()(<span class="Type">int</span> a) {
<span id="L8" class="LineNr"> 8 </span>      <span class="Statement">return</span> a + <span class="Constant">3</span>;
<span id="L9" class="LineNr"> 9 </span>    }
<span id="L10" class="LineNr">10 </span>};
<span id="L11" class="LineNr">11 </span>
<span id="L12" class="LineNr">12 </span><span class="Type">int</span> main() {
<span id="L13" class="LineNr">13 </span>  <span class="Type">auto</span> lambda = [] (<span class="Type">int</span> a) { <span class="Statement">return</span> a + <span class="Constant">3</span>; };
<span id="L14" class="LineNr">14 </span>
<span id="L15" class="LineNr">15 </span>  Functor functor;
<span id="L16" class="LineNr">16 </span>
<span id="L17" class="LineNr">17 </span>  <span class="Type">volatile</span> <span class="Type">int</span> y1 = function(<span class="Constant">5</span>);
<span id="L18" class="LineNr">18 </span>  <span class="Type">volatile</span> <span class="Type">int</span> y2 = functor(<span class="Constant">5</span>);
<span id="L19" class="LineNr">19 </span>  <span class="Type">volatile</span> <span class="Type">int</span> y3 = lambda(<span class="Constant">5</span>);
<span id="L20" class="LineNr">20 </span>
<span id="L21" class="LineNr">21 </span>  <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L22" class="LineNr">22 </span>}
</pre>
</p>

<p>
And below, we have the disassembly from each approach, along with the disassembler's best guess at what lines of the source file are associated with
various parts of the assembly code. (Thus, certain lines may not appear or may appear multiple times; assembly does not necessarily map directly to C++!)
I've pared the results down to just the relevant snippets.
</p>
<p>
<h4>Plain function:</h4>
<pre id='vimCodeElement'>
<span id="L102" class="LineNr">102 </span><span class="Header">00000000004004c6 &lt;function(int)&gt;:</span>
<span id="L103" class="LineNr">103 </span><span class="CPP">int function (int a) {</span>
<span id="L104" class="LineNr">104 </span>  4004c6: 55                    push   rbp
<span id="L105" class="LineNr">105 </span>  4004c7: 48 89 e5              mov    rbp,rsp
<span id="L106" class="LineNr">106 </span>  4004ca: 89 7d fc              mov    DWORD PTR [rbp-0x4],edi
<span id="L107" class="LineNr">107 </span><span class="CPP">  return a + 3;</span>
<span id="L108" class="LineNr">108 </span>  4004cd: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]
<span id="L109" class="LineNr">109 </span>  4004d0: 83 c0 03              add    eax,0x3
<span id="L110" class="LineNr">110 </span><span class="CPP">}</span>
<span id="L111" class="LineNr">111 </span>  4004d3: 5d                    pop    rbp
<span id="L112" class="LineNr">112 </span>  4004d4: c3                    ret
</pre>
</p>
<p>
Here, the parameter <code>a</code> is passed in the register <code>edi</code>, and the return value is placed in the <code>eax</code> register.
The assembly was not optimized at all, so lines 106 and 108 place the argument on the stack, then immediately retrieve it.
(In Intel x86 assembly syntax, the use of <code>[]</code> works like a pointer dereference; <code>rbp</code> contains the "base pointer", a
pointer to the top of the stack frame.)
The stack frame is 4 bytes (hence the <code>rbp-0x4</code>) since there is only one 4-byte value stored on it.
Line 109 actually performs the addition; the remainder of the lines consist of setting up and cleaning up various registers for the function call.
</p>

<p>
<h4>Functor:</h4>
<pre>
<span id="L162" class="LineNr">162 </span><span class="Header">000000000040052e &lt;Functor::operator()(int)&gt;:</span>
<span id="L163" class="LineNr">163 </span><span class="CPP">    int operator()(int a) {</span>
<span id="L164" class="LineNr">164 </span>  40052e: 55                    push   rbp
<span id="L165" class="LineNr">165 </span>  40052f: 48 89 e5              mov    rbp,rsp
<span id="L166" class="LineNr">166 </span>  400532: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L167" class="LineNr">167 </span>  400536: 89 75 f4              mov    DWORD PTR [rbp-0xc],esi
<span id="L168" class="LineNr">168 </span><span class="CPP">      return a + 3;</span>
<span id="L169" class="LineNr">169 </span>  400539: 8b 45 f4              mov    eax,DWORD PTR [rbp-0xc]
<span id="L170" class="LineNr">170 </span>  40053c: 83 c0 03              add    eax,0x3
<span id="L171" class="LineNr">171 </span><span class="CPP">    }</span>
<span id="L172" class="LineNr">172 </span>  40053f: 5d                    pop    rbp
<span id="L173" class="LineNr">173 </span>  400540: c3                    ret
</pre>
</p>

<p>
<h4>Lambda:</h4>
<pre>
<span id="L115" class="LineNr">115 </span><span class="Header">00000000004004d6 &lt;main::{lambda(int)#1}::operator()(int) const&gt;:</span>
<span id="L121" class="LineNr">121 </span><span class="CPP">  auto lambda = [] (int a) { return a + 3; };</span>
<span id="L122" class="LineNr">122 </span>  4004d6: 55                    push   rbp
<span id="L123" class="LineNr">123 </span>  4004d7: 48 89 e5              mov    rbp,rsp
<span id="L124" class="LineNr">124 </span>  4004da: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L125" class="LineNr">125 </span>  4004de: 89 75 f4              mov    DWORD PTR [rbp-0xc],esi
<span id="L126" class="LineNr">126 </span>  4004e1: 8b 45 f4              mov    eax,DWORD PTR [rbp-0xc]
<span id="L127" class="LineNr">127 </span>  4004e4: 83 c0 03              add    eax,0x3
<span id="L128" class="LineNr">128 </span>  4004e7: 5d                    pop    rbp
<span id="L129" class="LineNr">129 </span>  4004e8: c3                    ret
</pre></p>
<p>
The code generated from the functor class and the lambda are identical, but differ from the plain function in one way:
there is a hidden first parameter passed in <code>rdi</code> (due to <a href="https://en.wikipedia.org/wiki/X86#x86_registers">x86 weirdness</a>,
this is the same register as <code>edi</code>, but it holds 8 bytes instead of 4).
<!-- I am not sure what this parameter is yet; if you look at <code>main()</code>, the parameter passed is a pointer to a single byte
in <code>main()</code>'s stack frame. I'm like 99% sure it's the 'this' pointer -->
It is unused in this function; we will see its purpose later on.
The parameter <code>a</code> is thus passed in <code>esi</code> instead of <code>edi</code>.
Due to this hidden parameter, the stack frame is now 12 bytes; 4 for <code>a</code> and 8 for the hidden parameter.
</p>

<h4>Summary:</h4>
<p>
For plain functions that capture no variables, lambdas and functors behave the same. They differ from a plain C++ function only
in that they take an additional hidden parameter, thus requiring an extra 8 bytes of stack space.
(In addition, they require a single byte on <code>main()</code>'s stack that is related to the hidden parameter.)
</p>

<h3>Capture By Value</h3>
<p>
When capturing variables, we cannot use a standard C++ function, so we are left with two approaches: functor classes and lambdas.
The code below implements a simple function using each technique.
</p>
<p><pre>
<span id="L1" class="LineNr"> 1 </span><span class="Type">class</span> Functor {
<span id="L2" class="LineNr"> 2 </span>  <span class="Statement">public</span>:
<span id="L3" class="LineNr"> 3 </span>    Functor(<span class="Type">const</span> <span class="Type">int</span> x): m_x(x) {}
<span id="L4" class="LineNr"> 4 </span>
<span id="L5" class="LineNr"> 5 </span>    <span class="Type">int</span> <span class="Operator">operator</span>()(<span class="Type">int</span> a) {
<span id="L6" class="LineNr"> 6 </span>      <span class="Statement">return</span> a + m_x;
<span id="L7" class="LineNr"> 7 </span>    }
<span id="L8" class="LineNr"> 8 </span>
<span id="L9" class="LineNr"> 9 </span>  <span class="Statement">private</span>:
<span id="L10" class="LineNr">10 </span>    <span class="Type">int</span> m_x;
<span id="L11" class="LineNr">11 </span>};
<span id="L12" class="LineNr">12 </span>
<span id="L13" class="LineNr">13 </span><span class="Type">int</span> main() {
<span id="L14" class="LineNr">14 </span>  <span class="Type">int</span> x = <span class="Constant">3</span>;
<span id="L15" class="LineNr">15 </span>
<span id="L16" class="LineNr">16 </span>  <span class="Type">auto</span> lambda = [=] (<span class="Type">int</span> a) { <span class="Statement">return</span> a + x; };
<span id="L17" class="LineNr">17 </span>  Functor functor(x);
<span id="L18" class="LineNr">18 </span>
<span id="L19" class="LineNr">19 </span>  <span class="Type">volatile</span> <span class="Type">int</span> y1 = functor(<span class="Constant">5</span>);
<span id="L20" class="LineNr">20 </span>  <span class="Type">volatile</span> <span class="Type">int</span> y2 = lambda(<span class="Constant">5</span>);
<span id="L21" class="LineNr">21 </span>
<span id="L22" class="LineNr">22 </span>  <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L23" class="LineNr">23 </span>}
</pre></p>

<h4>Functor:</h4>
<p>The functor now has two functions for us to examine, the constructor and the call operator:</p>
<p><pre>
<span id="L157" class="LineNr">157 </span><span class="Header">0000000000400534 &lt;Functor::Functor(int)&gt;:</span>
<span id="L158" class="LineNr">158 </span><span class="CPP">    Functor(const int x): m_x(x) {}</span>
<span id="L159" class="LineNr">159 </span>  400534: 55                    push   rbp
<span id="L160" class="LineNr">160 </span>  400535: 48 89 e5              mov    rbp,rsp
<span id="L161" class="LineNr">161 </span>  400538: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L162" class="LineNr">162 </span>  40053c: 89 75 f4              mov    DWORD PTR [rbp-0xc],esi
<span id="L163" class="LineNr">163 </span>  40053f: 48 8b 45 f8           mov    rax,QWORD PTR [rbp-0x8]
<span id="L164" class="LineNr">164 </span>  400543: 8b 55 f4              mov    edx,DWORD PTR [rbp-0xc]
<span id="L165" class="LineNr">165 </span>  400546: 89 10                 mov    DWORD PTR [rax],edx
<span id="L166" class="LineNr">166 </span>  400548: 90                    nop
<span id="L167" class="LineNr">167 </span>  400549: 5d                    pop    rbp
<span id="L168" class="LineNr">168 </span>  40054a: c3                    ret
</pre></p>

<p>
The constructor's assembly is a very long way of saying "put the contents of <code>esi</code> into the memory location stored in <code>rdi</code>".
To find out what is passed as the two arguments to this function, let's have a look at the code in <code>main()</code> that calls the constructor:
</p>
<p><pre>
<span id="L125" class="LineNr">125 </span><span class="CPP">  int x = 3;</span>
<span id="L126" class="LineNr">126 </span>  4004e6: c7 45 fc 03 00 00 00  mov    DWORD PTR [rbp-0x4],0x3
<span class="CPP">...</span>
<span id="L130" class="LineNr">130 </span><span class="CPP">  Functor functor(x);</span>
<span id="L131" class="LineNr">131 </span>  4004f3: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]
<span id="L132" class="LineNr">132 </span>  4004f6: 48 8d 45 e0           lea    rax,[rbp-0x20]
<span id="L133" class="LineNr">133 </span>  4004fa: 89 d6                 mov    esi,edx
<span id="L134" class="LineNr">134 </span>  4004fc: 48 89 c7              mov    rdi,rax
<span id="L135" class="LineNr">135 </span>  4004ff: e8 30 00 00 00        call   400534 &lt;Functor::Functor(int)&gt;
</pre></p>

<p>
So, we see (from line 126) that <code>x</code> is stored at <code>rbp-0x4</code>, and is (indirectly, via lines 131 and 133) copied into <code>esi</code>.
Lines 132 and 134 place the address <code>rbp-0x20</code> into <code>rdi</code> (<code>lea</code> stands for "load effective addresss").
This address, naturally, is the <code>this</code> pointer for our functor object!
</p>

<p>
<p><pre>
<span id="L171" class="LineNr">171 </span><span class="Header">000000000040054c &lt;Functor::operator()(int)&gt;:</span>
<span id="L172" class="LineNr">172 </span><span class="CPP">    int operator()(int a) {</span>
<span id="L173" class="LineNr">173 </span>  40054c: 55                    push   rbp
<span id="L174" class="LineNr">174 </span>  40054d: 48 89 e5              mov    rbp,rsp
<span id="L175" class="LineNr">175 </span>  400550: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L176" class="LineNr">176 </span>  400554: 89 75 f4              mov    DWORD PTR [rbp-0xc],esi
<span id="L177" class="LineNr">177 </span><span class="CPP">      return a + m_x;</span>
<span id="L178" class="LineNr">178 </span>  400557: 48 8b 45 f8           mov    rax,QWORD PTR [rbp-0x8]
<span id="L179" class="LineNr">179 </span>  40055b: 8b 10                 mov    edx,DWORD PTR [rax]
<span id="L180" class="LineNr">180 </span>  40055d: 8b 45 f4              mov    eax,DWORD PTR [rbp-0xc]
<span id="L181" class="LineNr">181 </span>  400560: 01 d0                 add    eax,edx
<span id="L182" class="LineNr">182 </span><span class="CPP">    }</span>
<span id="L183" class="LineNr">183 </span>  400562: 5d                    pop    rbp
<span id="L184" class="LineNr">184 </span>  400563: c3                    ret
</pre></p>

<p>
The code for the actual function call is very similar to that of the plain function version.
The major difference is on lines 178 and 179, which load the value of <code>m_x</code> stored by our constructor into <code>edx</code>.
</p>

<h4>Lambda:</h4>
<p><pre>
<span id="L102" class="LineNr">102 </span><span class="Header">00000000004004c6 &lt;main::{lambda(int)#1}::operator()(int) const&gt;:</span>
<span id="L108" class="LineNr">108 </span><span class="CPP">  auto lambda = [=] (int a) { return a + x; };</span>
<span id="L109" class="LineNr">109 </span>  4004c6: 55                    push   rbp
<span id="L110" class="LineNr">110 </span>  4004c7: 48 89 e5              mov    rbp,rsp
<span id="L111" class="LineNr">111 </span>  4004ca: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L112" class="LineNr">112 </span>  4004ce: 89 75 f4              mov    DWORD PTR [rbp-0xc],esi
<span id="L113" class="LineNr">113 </span>  4004d1: 48 8b 45 f8           mov    rax,QWORD PTR [rbp-0x8]
<span id="L114" class="LineNr">114 </span>  4004d5: 8b 10                 mov    edx,DWORD PTR [rax]
<span id="L115" class="LineNr">115 </span>  4004d7: 8b 45 f4              mov    eax,DWORD PTR [rbp-0xc]
<span id="L116" class="LineNr">116 </span>  4004da: 01 d0                 add    eax,edx
<span id="L117" class="LineNr">117 </span>  4004dc: 5d                    pop    rbp
<span id="L118" class="LineNr">118 </span>  4004dd: c3                    ret
</pre></p>

<p>
The code for the lambda function call is identical to that of our functor's <code>operator()</code>. No surprise there.
But, where is the constructor function? Let's look in <code>main()</code>:
</p>
<p><pre>
<span id="L120" class="LineNr">120 </span><span class="Header">00000000004004de &lt;main&gt;:</span>
<span id="L121" class="LineNr">121 </span><span class="CPP">int main() {</span>
<span id="L122" class="LineNr">122 </span>  4004de: 55                    push   rbp
<span id="L123" class="LineNr">123 </span>  4004df: 48 89 e5              mov    rbp,rsp
<span id="L124" class="LineNr">124 </span>  4004e2: 48 83 ec 30           sub    rsp,0x30
<span id="L125" class="LineNr">125 </span><span class="CPP">  int x = 3;</span>
<span id="L126" class="LineNr">126 </span>  4004e6: c7 45 fc 03 00 00 00  mov    DWORD PTR [rbp-0x4],0x3
<span id="L127" class="LineNr">127 </span><span class="CPP">  auto lambda = [=] (int a) { return a + x; };</span>
<span id="L128" class="LineNr">128 </span>  4004ed: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]
<span id="L129" class="LineNr">129 </span>  4004f0: 89 45 f0              mov    DWORD PTR [rbp-0x10],eax
</pre></p>

<p>
All the work of the functor's constructor is done in lines 128 and 129! The <code>this</code> pointer for the lambda is
the memory address <code>rbp-0x10</code>, as opposed to <code>rbp-0x20</code> for the functor; they are in this order due
to the order in which we declare them.
<!--(I suspect the reason for the 16-byte difference between the two addresses is due to memory
	alignment requirements, but that is neither here nor there.)-->
</p>

<h4>Summary:</h4>
<p>
Capture-by-value lambdas work almost identically to a standard functor: they both allocate an underlying object where the captured value
is stored and take a hidden function parameter pointing to this object.
The code executed by the function call for both the lambda and the functor are the same.
The sole difference is that the lambda's constructor is inlined into the function where the lambda is created, rather than being
a separate function like the functor's constructor.
</p>

<h3>Capture By Reference</h3>
<p>
When capturing by reference, the value captured can be modified in the same manner as a parameter passed by reference to a normal C++ function.
As with capturing by value, we can implement this behavior using either a functor or a lambda:
</p>

<p><pre>
<span id="L1" class="LineNr"> 1 </span><span class="Type">class</span> Functor {
<span id="L2" class="LineNr"> 2 </span>  <span class="Statement">public</span>:
<span id="L3" class="LineNr"> 3 </span>    Functor(<span class="Type">int</span>&amp; x): m_x(x) {}
<span id="L4" class="LineNr"> 4 </span>
<span id="L5" class="LineNr"> 5 </span>    <span class="Type">int</span> <span class="Operator">operator</span>()(<span class="Type">int</span> a) {
<span id="L6" class="LineNr"> 6 </span>      <span class="Statement">return</span> a + m_x++;
<span id="L7" class="LineNr"> 7 </span>    }
<span id="L8" class="LineNr"> 8 </span>
<span id="L9" class="LineNr"> 9 </span>  <span class="Statement">private</span>:
<span id="L10" class="LineNr">10 </span>    <span class="Type">int</span>&amp; m_x;
<span id="L11" class="LineNr">11 </span>};
<span id="L12" class="LineNr">12 </span>
<span id="L13" class="LineNr">13 </span><span class="Type">int</span> main() {
<span id="L14" class="LineNr">14 </span>  <span class="Type">int</span> x = <span class="Constant">3</span>;
<span id="L15" class="LineNr">15 </span>
<span id="L16" class="LineNr">16 </span>  <span class="Type">auto</span> lambda = [&amp;] (<span class="Type">int</span> a) { <span class="Statement">return</span> a + x++; };
<span id="L17" class="LineNr">17 </span>
<span id="L18" class="LineNr">18 </span>  Functor functor(x);
<span id="L19" class="LineNr">19 </span>
<span id="L20" class="LineNr">20 </span>  <span class="Type">volatile</span> <span class="Type">int</span> y1 = functor(<span class="Constant">5</span>);
<span id="L21" class="LineNr">21 </span>  <span class="Type">volatile</span> <span class="Type">int</span> y2 = lambda(<span class="Constant">5</span>);
<span id="L22" class="LineNr">22 </span>
<span id="L23" class="LineNr">23 </span>  <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L24" class="LineNr">24 </span>}
</pre></p>

<h4>Functor:</h4>
Again, our functor will have both a constructor and a call operator. We should expect this to behave similarly
to the capture-by-value version, and GCC does not disappoint.
<p><pre>
<span id="L161" class="LineNr">161 </span><span class="Header">0000000000400540 &lt;Functor::Functor(int&amp;)&gt;:</span>
<span id="L162" class="LineNr">162 </span><span class="CPP">    Functor(int&amp; x): m_x(x) {}</span>
<span id="L163" class="LineNr">163 </span>  400540: 55                    push   rbp
<span id="L164" class="LineNr">164 </span>  400541: 48 89 e5              mov    rbp,rsp
<span id="L165" class="LineNr">165 </span>  400544: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L166" class="LineNr">166 </span>  400548: 48 89 75 f0           mov    QWORD PTR [rbp-0x10],rsi
<span id="L167" class="LineNr">167 </span>  40054c: 48 8b 45 f8           mov    rax,QWORD PTR [rbp-0x8]
<span id="L168" class="LineNr">168 </span>  400550: 48 8b 55 f0           mov    rdx,QWORD PTR [rbp-0x10]
<span id="L169" class="LineNr">169 </span>  400554: 48 89 10              mov    QWORD PTR [rax],rdx
<span id="L170" class="LineNr">170 </span>  400557: 90                    nop
<span id="L171" class="LineNr">171 </span>  400558: 5d                    pop    rbp
<span id="L172" class="LineNr">172 </span>  400559: c3                    ret
</pre></p>

<p>The sole difference from the capture-by-value constructor is that our second parameter is now an 8-byte value, and thus in <code>rsi</code>
instead of <code>esi</code>. You might suspect that this second parameter is a pointer to <code>x</code> in <code>main()</code> and you would
not be wrong:
</p>
<p><pre>
<span id="L128" class="LineNr">128 </span><span class="CPP">  int x = 3;</span>
<span id="L129" class="LineNr">129 </span>  4004ee: c7 45 fc 03 00 00 00  mov    DWORD PTR [rbp-0x4],0x3
<span class="CPP">...</span>
<span id="L134" class="LineNr">134 </span><span class="CPP">  Functor functor(x);</span>
<span id="L135" class="LineNr">135 </span>  4004fd: 48 8d 55 fc           lea    rdx,[rbp-0x4]
<span id="L136" class="LineNr">136 </span>  400501: 48 8d 45 e0           lea    rax,[rbp-0x20]
<span id="L137" class="LineNr">137 </span>  400505: 48 89 d6              mov    rsi,rdx
<span id="L138" class="LineNr">138 </span>  400508: 48 89 c7              mov    rdi,rax
<span id="L139" class="LineNr">139 </span>  40050b: e8 30 00 00 00        call   400540 &lt;Functor::Functor(int&amp;)&gt;
</pre></p>

<p>Lines 135 and 137 put a pointer to <code>x</code> (allocated on line 129) into <code>rsi</code>.
The remainder of the code sets up the <code>this</code> pointer for the constructor, as before.
</p>

<p><pre>
<span id="L174" class="LineNr">174 </span><span class="Header">000000000040055a &lt;Functor::operator()(int)&gt;:</span>
<span id="L175" class="LineNr">175 </span><span class="CPP">    int operator()(int a) {</span>
<span id="L176" class="LineNr">176 </span>  40055a: 55                    push   rbp
<span id="L177" class="LineNr">177 </span>  40055b: 48 89 e5              mov    rbp,rsp
<span id="L178" class="LineNr">178 </span>  40055e: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L179" class="LineNr">179 </span>  400562: 89 75 f4              mov    DWORD PTR [rbp-0xc],esi
<span id="L180" class="LineNr">180 </span><span class="CPP">      return a + m_x++;</span>
<span id="L181" class="LineNr">181 </span>  400565: 48 8b 45 f8           mov    rax,QWORD PTR [rbp-0x8]
<span id="L182" class="LineNr">182 </span>  400569: 48 8b 00              mov    rax,QWORD PTR [rax]
<span id="L183" class="LineNr">183 </span>  40056c: 8b 10                 mov    edx,DWORD PTR [rax]
<span id="L184" class="LineNr">184 </span>  40056e: 8d 4a 01              lea    ecx,[rdx+0x1]
<span id="L185" class="LineNr">185 </span>  400571: 89 08                 mov    DWORD PTR [rax],ecx
<span id="L186" class="LineNr">186 </span>  400573: 8b 45 f4              mov    eax,DWORD PTR [rbp-0xc]
<span id="L187" class="LineNr">187 </span>  400576: 01 d0                 add    eax,edx
<span id="L188" class="LineNr">188 </span><span class="CPP">    }</span>
<span id="L189" class="LineNr">189 </span>  400578: 5d                    pop    rbp
<span id="L190" class="LineNr">190 </span>  400579: c3                    ret
</pre></p>

<p>The function call is noticably different from the capture-by-value version, as we'd expect: we are performing both an addition and an increment,
and the increment has to propagate back to <code>main()</code>. But wait, there's only one <code>add</code> instruction! What's going on here?
</p>

<p>First, <code>this</code> ends up in <code>rax</code> via lines 178 and 181. Now, recall that the value there is a pointer to the functor object,
which consists of one pointer <code>m_x</code> to the memory location (of <code>x</code>) we passed the constructor. So we're two layers of indirection
away from the value we need. Lines 182 and 183 perform the double-dereference needed to copy the value of <code>x</code> to <code>edx</code>.
</p>

<p>Line 184 is an unusual way of writing an increment! Recall that <code>edx</code> and <code>rdx</code> are the same register; <code>lea</code> expects
and 8-byte source (since it was meant to do pointer arithmetic and we're on a 64-bit system).
The result of adding 1 to <code>edx</code> is stored in <code>ecx</code>; this is the value <code>m_x++</code>.
Line 185 copies this value back to where <code>rax</code> is pointing&emdash;which is <code>x</code> in <code>main()</code>.
</p>

<p>
Lastly, lines 179 and 186 copy the second parameter, <code>a</code>, into <code>eax</code>, and line 187 performs the addition, as in previous versions.
</p>

<h4>Lambda:</h4>
As with capture-by-value, the only difference between the functor and the lambda is that the lambda's "constructor" is inlined
into <code>main()</code>, on lines 131 and 132:

<p><pre>
<span id="L123" class="LineNr">123 </span><span class="Header">00000000004004e6 &lt;main&gt;:</span>
<span id="L124" class="LineNr">124 </span><span class="CPP">int main() {</span>
<span id="L125" class="LineNr">125 </span>  4004e6: 55                    push   rbp
<span id="L126" class="LineNr">126 </span>  4004e7: 48 89 e5              mov    rbp,rsp
<span id="L127" class="LineNr">127 </span>  4004ea: 48 83 ec 30           sub    rsp,0x30
<span id="L128" class="LineNr">128 </span><span class="CPP">  int x = 3;</span>
<span id="L129" class="LineNr">129 </span>  4004ee: c7 45 fc 03 00 00 00  mov    DWORD PTR [rbp-0x4],0x3
<span id="L130" class="LineNr">130 </span><span class="CPP">  auto lambda = [&amp;] (int a) { return a + x++; };</span>
<span id="L131" class="LineNr">131 </span>  4004f5: 48 8d 45 fc           lea    rax,[rbp-0x4]
<span id="L132" class="LineNr">132 </span>  4004f9: 48 89 45 f0           mov    QWORD PTR [rbp-0x10],rax
</pre></p>

The code executed when the lambda is called is identical:

<p><pre>
<span id="L102" class="LineNr">102 </span><span class="Header">00000000004004c6 &lt;main::{lambda(int)#1}::operator()(int) const&gt;:</span>
<span id="L108" class="LineNr">108 </span><span class="CPP">  auto lambda = [&amp;] (int a) { return a + x++; };</span>
<span id="L109" class="LineNr">109 </span>  4004c6: 55                    push   rbp
<span id="L110" class="LineNr">110 </span>  4004c7: 48 89 e5              mov    rbp,rsp
<span id="L111" class="LineNr">111 </span>  4004ca: 48 89 7d f8           mov    QWORD PTR [rbp-0x8],rdi
<span id="L112" class="LineNr">112 </span>  4004ce: 89 75 f4              mov    DWORD PTR [rbp-0xc],esi
<span id="L113" class="LineNr">113 </span>  4004d1: 48 8b 45 f8           mov    rax,QWORD PTR [rbp-0x8]
<span id="L114" class="LineNr">114 </span>  4004d5: 48 8b 00              mov    rax,QWORD PTR [rax]
<span id="L115" class="LineNr">115 </span>  4004d8: 8b 10                 mov    edx,DWORD PTR [rax]
<span id="L116" class="LineNr">116 </span>  4004da: 8d 4a 01              lea    ecx,[rdx+0x1]
<span id="L117" class="LineNr">117 </span>  4004dd: 89 08                 mov    DWORD PTR [rax],ecx
<span id="L118" class="LineNr">118 </span>  4004df: 8b 45 f4              mov    eax,DWORD PTR [rbp-0xc]
<span id="L119" class="LineNr">119 </span>  4004e2: 01 d0                 add    eax,edx
<span id="L120" class="LineNr">120 </span>  4004e4: 5d                    pop    rbp
<span id="L121" class="LineNr">121 </span>  4004e5: c3                    ret
</pre> </p>

<h4>Summary:</h4>
<p>
When capturing by reference, the functor and lambda objects contain a pointer instead of a value, demonstrating that the behavior of references
is implemented using pointers under the hood.
As with capture-by-value, the functor and lambda call code is equivalent, but the lambda's constructor is inlined, whereas the functor's is not.
</p>

<h3>Conclusion</h3>
<p>
C++ lambdas and functors are more similar than they are different. This is to be expected; the main goal of lambdas is to be a syntactically simple
means of creating functions and closures. They differ slightly from plain functions, even when no variables are being captured.
To summarize the key differences:
<ol>
	<li>Functors and lambdas are always passed a <code>this</code> pointer, whereas plain functions naturally are not. This consumes an extra register
		and 8 bytes of stack space.</li>
	<li>Lambda "constructors" are inlined into the function in which the lambda is created. This significantly reduces the amount of copying performed
		(2 instructions for lambdas, 5 for functors), as well as avoiding a function call setup and teardown.</li>
</ol>
</p>

<p>Overall, the costs for #1 are minor, and are probably eliminated by an optimization pass in the compiler. The costs for #2 are somewhat higher,
but they are cheaper for lambdas! Again, I suspect that an optimization pass would eliminate the difference between the two.
</p>

<h4>Homework</h4>
If you want to learn more, here are some things to investigate:
<ol>
	<li>What impact do various optimization levels (<code>-O1</code>, <code>-O2</code>, <code>-Os</code>, and/or <code>-Og</code>) have on this analysis?</li>
	<li>How does the output of Clang differ from that of GCC?</li>
</ol>
</body>
</html>
